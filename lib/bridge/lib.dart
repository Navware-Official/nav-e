// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Initialize the database with the platform-specific path
/// Must be called before any database operations
Future<void> initializeDatabase({required String dbPath}) =>
    RustBridge.instance.api.crateInitializeDatabase(dbPath: dbPath);

/// Calculate a route between waypoints
Future<String> calculateRoute({required List<(double, double)> waypoints}) =>
    RustBridge.instance.api.crateCalculateRoute(waypoints: waypoints);

/// Start a new navigation session
Future<String> startNavigationSession({
  required List<(double, double)> waypoints,
  required (double, double) currentPosition,
}) => RustBridge.instance.api.crateStartNavigationSession(
  waypoints: waypoints,
  currentPosition: currentPosition,
);

/// Update current position during navigation
Future<void> updateNavigationPosition({
  required String sessionId,
  required double latitude,
  required double longitude,
}) => RustBridge.instance.api.crateUpdateNavigationPosition(
  sessionId: sessionId,
  latitude: latitude,
  longitude: longitude,
);

/// Get the currently active navigation session
Future<String?> getActiveSession() =>
    RustBridge.instance.api.crateGetActiveSession();

/// Pause active navigation
Future<void> pauseNavigation({required String sessionId}) =>
    RustBridge.instance.api.cratePauseNavigation(sessionId: sessionId);

/// Resume paused navigation
Future<void> resumeNavigation({required String sessionId}) =>
    RustBridge.instance.api.crateResumeNavigation(sessionId: sessionId);

/// Stop and complete navigation session
Future<void> stopNavigation({required String sessionId}) =>
    RustBridge.instance.api.crateStopNavigation(sessionId: sessionId);

/// Search for locations by address/name
Future<String> geocodeSearch({required String query, int? limit}) =>
    RustBridge.instance.api.crateGeocodeSearch(query: query, limit: limit);

/// Reverse geocode coordinates to address
Future<String> reverseGeocode({
  required double latitude,
  required double longitude,
}) => RustBridge.instance.api.crateReverseGeocode(
  latitude: latitude,
  longitude: longitude,
);

/// Get all saved places as JSON array
String getAllSavedPlaces() => RustBridge.instance.api.crateGetAllSavedPlaces();

/// Get a saved place by ID as JSON object
String getSavedPlaceById({required PlatformInt64 id}) =>
    RustBridge.instance.api.crateGetSavedPlaceById(id: id);

/// Save a new place and return the assigned ID
PlatformInt64 savePlace({
  required String name,
  String? address,
  required double lat,
  required double lon,
  String? source,
  PlatformInt64? typeId,
  String? remoteId,
}) => RustBridge.instance.api.crateSavePlace(
  name: name,
  address: address,
  lat: lat,
  lon: lon,
  source: source,
  typeId: typeId,
  remoteId: remoteId,
);

/// Delete a saved place by ID
void deleteSavedPlace({required PlatformInt64 id}) =>
    RustBridge.instance.api.crateDeleteSavedPlace(id: id);

/// Send route data to a connected device via Bluetooth
///
/// # Arguments
/// * `device_id` - The device ID (from saved devices)
/// * `route_json` - JSON string containing route waypoints and metadata
///
/// # Returns
/// Result indicating success or failure
///
/// # Note
/// Currently returns a stub implementation. Full device communication
/// will be implemented using device_comm crate and protobuf protocol.
Future<void> sendRouteToDevice({
  required PlatformInt64 deviceId,
  required String routeJson,
}) => RustBridge.instance.api.crateSendRouteToDevice(
  deviceId: deviceId,
  routeJson: routeJson,
);

/// Get all devices as JSON array
String getAllDevices() => RustBridge.instance.api.crateGetAllDevices();

/// Get a device by ID as JSON object
String getDeviceById({required PlatformInt64 id}) =>
    RustBridge.instance.api.crateGetDeviceById(id: id);

/// Get a device by remote ID as JSON object
String getDeviceByRemoteId({required String remoteId}) =>
    RustBridge.instance.api.crateGetDeviceByRemoteId(remoteId: remoteId);

/// Save a new device from JSON and return the assigned ID
PlatformInt64 saveDevice({required String deviceJson}) =>
    RustBridge.instance.api.crateSaveDevice(deviceJson: deviceJson);

/// Update an existing device from JSON
void updateDevice({required PlatformInt64 id, required String deviceJson}) =>
    RustBridge.instance.api.crateUpdateDevice(id: id, deviceJson: deviceJson);

/// Delete a device by ID
void deleteDevice({required PlatformInt64 id}) =>
    RustBridge.instance.api.crateDeleteDevice(id: id);

/// Check if a device exists by remote ID
bool deviceExistsByRemoteId({required String remoteId}) =>
    RustBridge.instance.api.crateDeviceExistsByRemoteId(remoteId: remoteId);

/// Prepare a route message for sending to a device
/// Takes route JSON and returns serialized protobuf message bytes
Uint8List prepareRouteMessage({required String routeJson}) =>
    RustBridge.instance.api.cratePrepareRouteMessage(routeJson: routeJson);

/// Chunk a protobuf message into BLE frames
/// Returns a vector of frame bytes ready for BLE transmission
List<Uint8List> chunkMessageForBle({
  required List<int> messageBytes,
  required String routeId,
  required int mtu,
}) => RustBridge.instance.api.crateChunkMessageForBle(
  messageBytes: messageBytes,
  routeId: routeId,
  mtu: mtu,
);

/// Reassemble BLE frames back into a complete message
/// Returns the reassembled message bytes
Uint8List reassembleFrames({required List<Uint8List> frameBytes}) =>
    RustBridge.instance.api.crateReassembleFrames(frameBytes: frameBytes);

/// Create a control command message (ACK, NACK, START_NAV, etc.)
Uint8List createControlMessage({
  required String routeId,
  required String commandType,
  required int statusCode,
  required String message,
}) => RustBridge.instance.api.crateCreateControlMessage(
  routeId: routeId,
  commandType: commandType,
  statusCode: statusCode,
  message: message,
);
