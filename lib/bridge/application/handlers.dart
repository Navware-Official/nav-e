// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../api_v2.dart';
import '../domain/entities.dart';
import '../domain/value_objects.dart';
import '../frb_generated.dart';
import 'commands.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'queries.dart';

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < dyn DeviceCommunicationPort >>>
abstract class ArcDeviceCommunicationPort implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CalculateRouteHandler>>
abstract class CalculateRouteHandler implements RustOpaqueInterface {
  Future<Route> handle({required CalculateRouteQuery query});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<CalculateRouteHandler> newInstance({
    required ArcRouteService routeService,
  }) =>
      RustBridge.instance.api.crateApplicationHandlersCalculateRouteHandlerNew(
        routeService: routeService,
      );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GeocodeHandler>>
abstract class GeocodeHandler implements RustOpaqueInterface {
  Future<List<Position>> handle({required GeocodeQuery query});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<GeocodeHandler> newInstance({
    required ArcGeocodingService geocodingService,
  }) => RustBridge.instance.api.crateApplicationHandlersGeocodeHandlerNew(
    geocodingService: geocodingService,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GetActiveSessionHandler>>
abstract class GetActiveSessionHandler implements RustOpaqueInterface {
  Future<NavigationSession?> handle({required GetActiveSessionQuery query});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<GetActiveSessionHandler> newInstance({
    required ArcNavigationRepository navigationRepo,
  }) => RustBridge.instance.api
      .crateApplicationHandlersGetActiveSessionHandlerNew(
        navigationRepo: navigationRepo,
      );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PauseNavigationHandler>>
abstract class PauseNavigationHandler implements RustOpaqueInterface {
  Future<void> handle({required PauseNavigationCommand command});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<PauseNavigationHandler> newInstance({
    required ArcNavigationRepository navigationRepo,
  }) =>
      RustBridge.instance.api.crateApplicationHandlersPauseNavigationHandlerNew(
        navigationRepo: navigationRepo,
      );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ResumeNavigationHandler>>
abstract class ResumeNavigationHandler implements RustOpaqueInterface {
  Future<void> handle({required ResumeNavigationCommand command});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<ResumeNavigationHandler> newInstance({
    required ArcNavigationRepository navigationRepo,
  }) => RustBridge.instance.api
      .crateApplicationHandlersResumeNavigationHandlerNew(
        navigationRepo: navigationRepo,
      );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReverseGeocodeHandler>>
abstract class ReverseGeocodeHandler implements RustOpaqueInterface {
  Future<String> handle({required ReverseGeocodeQuery query});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<ReverseGeocodeHandler> newInstance({
    required ArcGeocodingService geocodingService,
  }) =>
      RustBridge.instance.api.crateApplicationHandlersReverseGeocodeHandlerNew(
        geocodingService: geocodingService,
      );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StartNavigationHandler>>
abstract class StartNavigationHandler implements RustOpaqueInterface {
  Future<NavigationSession> handle({required StartNavigationCommand command});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<StartNavigationHandler> newInstance({
    required ArcRouteService routeService,
    required ArcNavigationRepository navigationRepo,
    required ArcDeviceCommunicationPort deviceComm,
  }) =>
      RustBridge.instance.api.crateApplicationHandlersStartNavigationHandlerNew(
        routeService: routeService,
        navigationRepo: navigationRepo,
        deviceComm: deviceComm,
      );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StopNavigationHandler>>
abstract class StopNavigationHandler implements RustOpaqueInterface {
  Future<void> handle({required StopNavigationCommand command});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<StopNavigationHandler> newInstance({
    required ArcNavigationRepository navigationRepo,
  }) =>
      RustBridge.instance.api.crateApplicationHandlersStopNavigationHandlerNew(
        navigationRepo: navigationRepo,
      );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UpdatePositionHandler>>
abstract class UpdatePositionHandler implements RustOpaqueInterface {
  Future<void> handle({required UpdatePositionCommand command});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<UpdatePositionHandler> newInstance({
    required ArcNavigationRepository navigationRepo,
    required ArcDeviceCommunicationPort deviceComm,
  }) =>
      RustBridge.instance.api.crateApplicationHandlersUpdatePositionHandlerNew(
        navigationRepo: navigationRepo,
        deviceComm: deviceComm,
      );
}
