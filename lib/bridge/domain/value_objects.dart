// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `InstructionType`, `Instruction`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `with_arrival_time`, `with_features`, `with_time_remaining`

/// Battery information (value object)
class BatteryInfo {
  final int percentage;
  final bool isCharging;
  final int? timeRemainingMinutes;

  const BatteryInfo({
    required this.percentage,
    required this.isCharging,
    this.timeRemainingMinutes,
  });

  Future<bool> isCritical() => RustBridge.instance.api
      .crateDomainValueObjectsBatteryInfoIsCritical(that: this);

  Future<bool> isLow() => RustBridge.instance.api
      .crateDomainValueObjectsBatteryInfoIsLow(that: this);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<BatteryInfo> newInstance({
    required int percentage,
    required bool isCharging,
  }) => RustBridge.instance.api.crateDomainValueObjectsBatteryInfoNew(
    percentage: percentage,
    isCharging: isCharging,
  );

  @override
  int get hashCode =>
      percentage.hashCode ^ isCharging.hashCode ^ timeRemainingMinutes.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BatteryInfo &&
          runtimeType == other.runtimeType &&
          percentage == other.percentage &&
          isCharging == other.isCharging &&
          timeRemainingMinutes == other.timeRemainingMinutes;
}

/// Device capabilities (value object)
class DeviceCapabilities {
  final int screenWidth;
  final int screenHeight;
  final bool supportsColor;
  final bool supportsHaptic;
  final bool supportsVoice;
  final int batteryCapacityMah;

  const DeviceCapabilities({
    required this.screenWidth,
    required this.screenHeight,
    required this.supportsColor,
    required this.supportsHaptic,
    required this.supportsVoice,
    required this.batteryCapacityMah,
  });

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<DeviceCapabilities> newInstance({
    required int screenWidth,
    required int screenHeight,
  }) => RustBridge.instance.api.crateDomainValueObjectsDeviceCapabilitiesNew(
    screenWidth: screenWidth,
    screenHeight: screenHeight,
  );

  @override
  int get hashCode =>
      screenWidth.hashCode ^
      screenHeight.hashCode ^
      supportsColor.hashCode ^
      supportsHaptic.hashCode ^
      supportsVoice.hashCode ^
      batteryCapacityMah.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DeviceCapabilities &&
          runtimeType == other.runtimeType &&
          screenWidth == other.screenWidth &&
          screenHeight == other.screenHeight &&
          supportsColor == other.supportsColor &&
          supportsHaptic == other.supportsHaptic &&
          supportsVoice == other.supportsVoice &&
          batteryCapacityMah == other.batteryCapacityMah;
}

/// Geographic position (latitude, longitude)
class Position {
  final double latitude;
  final double longitude;

  const Position({required this.latitude, required this.longitude});

  Future<double> distanceTo({required Position other}) => RustBridge
      .instance
      .api
      .crateDomainValueObjectsPositionDistanceTo(that: this, other: other);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<Position> newInstance({
    required double latitude,
    required double longitude,
  }) => RustBridge.instance.api.crateDomainValueObjectsPositionNew(
    latitude: latitude,
    longitude: longitude,
  );

  @override
  int get hashCode => latitude.hashCode ^ longitude.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Position &&
          runtimeType == other.runtimeType &&
          latitude == other.latitude &&
          longitude == other.longitude;
}

/// A waypoint in a route
class Waypoint {
  final Position position;
  final String? name;
  final int? arrivalTime;
  final bool isVisited;

  const Waypoint({
    required this.position,
    this.name,
    this.arrivalTime,
    required this.isVisited,
  });

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<Waypoint> newInstance({
    required Position position,
    String? name,
  }) => RustBridge.instance.api.crateDomainValueObjectsWaypointNew(
    position: position,
    name: name,
  );

  @override
  int get hashCode =>
      position.hashCode ^
      name.hashCode ^
      arrivalTime.hashCode ^
      isVisited.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Waypoint &&
          runtimeType == other.runtimeType &&
          position == other.position &&
          name == other.name &&
          arrivalTime == other.arrivalTime &&
          isVisited == other.isVisited;
}
